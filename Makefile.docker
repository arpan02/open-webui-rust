.PHONY: help setup start stop restart logs status rebuild clean backup restore health shell dev-start dev-stop dev-tools

# Colors
BLUE := \033[0;34m
GREEN := \033[0;32m
YELLOW := \033[1;33m
NC := \033[0m # No Color

# Default target
.DEFAULT_GOAL := help

help: ## Show this help message
	@echo "$(GREEN)Open WebUI Docker Management$(NC)"
	@echo ""
	@echo "$(YELLOW)Production Commands:$(NC)"
	@awk 'BEGIN {FS = ":.*##"; printf ""} /^[a-zA-Z_-]+:.*?##/ { printf "  $(BLUE)%-15s$(NC) %s\n", $$1, $$2 }' $(MAKEFILE_LIST) | grep -v "dev-"
	@echo ""
	@echo "$(YELLOW)Development Commands:$(NC)"
	@awk 'BEGIN {FS = ":.*##"; printf ""} /^dev-[a-zA-Z_-]+:.*?##/ { printf "  $(BLUE)%-15s$(NC) %s\n", $$1, $$2 }' $(MAKEFILE_LIST)

setup: ## Setup environment file
	@echo "$(BLUE)Setting up environment...$(NC)"
	@if [ ! -f .env ]; then \
		cp env.example .env; \
		echo "$(GREEN)Created .env file$(NC)"; \
		if command -v openssl > /dev/null; then \
			SECRET=$$(openssl rand -hex 32); \
			if [[ "$$OSTYPE" == "darwin"* ]]; then \
				sed -i '' "s/WEBUI_SECRET_KEY=.*/WEBUI_SECRET_KEY=$$SECRET/" .env; \
			else \
				sed -i "s/WEBUI_SECRET_KEY=.*/WEBUI_SECRET_KEY=$$SECRET/" .env; \
			fi; \
			echo "$(GREEN)Generated WEBUI_SECRET_KEY$(NC)"; \
		else \
			echo "$(YELLOW)Please set WEBUI_SECRET_KEY in .env manually$(NC)"; \
		fi; \
	else \
		echo "$(YELLOW).env file already exists$(NC)"; \
	fi

start: ## Start all services
	@echo "$(BLUE)Starting all services...$(NC)"
	@docker-compose up -d
	@echo "$(GREEN)Services started!$(NC)"
	@echo "Access at: http://localhost:$${OPEN_WEBUI_PORT:-3000}"

stop: ## Stop all services
	@echo "$(BLUE)Stopping all services...$(NC)"
	@docker-compose down
	@echo "$(GREEN)Services stopped!$(NC)"

restart: ## Restart all services
	@echo "$(BLUE)Restarting all services...$(NC)"
	@docker-compose restart
	@echo "$(GREEN)Services restarted!$(NC)"

logs: ## View logs (use SERVICE=name to filter)
	@docker-compose logs -f $(SERVICE)

status: ## Show service status
	@docker-compose ps

rebuild: ## Rebuild services (use SERVICE=name to rebuild specific service)
	@echo "$(BLUE)Rebuilding services...$(NC)"
	@docker-compose build --no-cache $(SERVICE)
	@echo "$(GREEN)Rebuild complete!$(NC)"

clean: ## Stop services and remove volumes (⚠️ destructive)
	@echo "$(YELLOW)⚠️  This will delete all data!$(NC)"
	@read -p "Are you sure? (yes/no): " confirm; \
	if [ "$$confirm" = "yes" ]; then \
		echo "$(BLUE)Cleaning up...$(NC)"; \
		docker-compose down -v; \
		docker system prune -f; \
		echo "$(GREEN)Cleanup complete!$(NC)"; \
	else \
		echo "Cancelled."; \
	fi

backup: ## Backup database and uploads
	@echo "$(BLUE)Creating backup...$(NC)"
	@mkdir -p backups
	@docker-compose exec -T postgres pg_dump -U $${POSTGRES_USER:-open_webui} $${POSTGRES_DB:-open_webui} > backups/db_backup_$$(date +%Y%m%d_%H%M%S).sql
	@echo "$(GREEN)Database backup created!$(NC)"
	@docker run --rm \
		-v open-webui-rust_rust_backend_data:/data \
		-v $$(pwd)/backups:/backup \
		alpine tar czf /backup/uploads_backup_$$(date +%Y%m%d_%H%M%S).tar.gz -C /data .
	@echo "$(GREEN)Uploads backup created!$(NC)"

restore: ## Restore database (use FILE=path/to/backup.sql)
	@if [ -z "$(FILE)" ]; then \
		echo "$(YELLOW)Usage: make restore FILE=path/to/backup.sql$(NC)"; \
		exit 1; \
	fi
	@echo "$(BLUE)Restoring database from $(FILE)...$(NC)"
	@cat $(FILE) | docker-compose exec -T postgres psql -U $${POSTGRES_USER:-open_webui} $${POSTGRES_DB:-open_webui}
	@echo "$(GREEN)Database restored!$(NC)"

health: ## Check health of all services
	@echo "$(BLUE)Checking service health...$(NC)"
	@echo ""
	@for service in postgres redis rust-backend socketio-bridge frontend; do \
		if docker-compose ps -q $$service > /dev/null 2>&1; then \
			if docker-compose ps $$service | grep -q "Up"; then \
				echo "$(GREEN)✓$(NC) $$service: Running"; \
			else \
				echo "$(YELLOW)✗$(NC) $$service: Not running"; \
			fi; \
		else \
			echo "$(YELLOW)✗$(NC) $$service: Not found"; \
		fi; \
	done
	@echo ""

shell: ## Open shell in service (use SERVICE=name)
	@if [ -z "$(SERVICE)" ]; then \
		echo "$(YELLOW)Usage: make shell SERVICE=service_name$(NC)"; \
		echo "Available: postgres, redis, rust-backend, socketio-bridge, frontend"; \
		exit 1; \
	fi
	@if [ "$(SERVICE)" = "postgres" ]; then \
		docker-compose exec $(SERVICE) psql -U $${POSTGRES_USER:-open_webui} $${POSTGRES_DB:-open_webui}; \
	else \
		docker-compose exec $(SERVICE) sh; \
	fi

# Development targets
dev-start: ## Start development infrastructure (PostgreSQL, Redis, Socket.IO)
	@echo "$(BLUE)Starting development infrastructure...$(NC)"
	@docker-compose -f docker-compose.dev.yaml up -d
	@echo "$(GREEN)Development infrastructure started!$(NC)"
	@echo ""
	@echo "$(YELLOW)Next steps:$(NC)"
	@echo "  1. cd rust-backend && cargo run"
	@echo "  2. npm run dev"

dev-stop: ## Stop development infrastructure
	@echo "$(BLUE)Stopping development infrastructure...$(NC)"
	@docker-compose -f docker-compose.dev.yaml down
	@echo "$(GREEN)Development infrastructure stopped!$(NC)"

dev-tools: ## Start development infrastructure with admin tools (pgAdmin, Redis Commander)
	@echo "$(BLUE)Starting development infrastructure with tools...$(NC)"
	@docker-compose -f docker-compose.dev.yaml --profile tools up -d
	@echo "$(GREEN)Development infrastructure with tools started!$(NC)"
	@echo ""
	@echo "$(YELLOW)Available tools:$(NC)"
	@echo "  - pgAdmin: http://localhost:5050 (admin@admin.com / admin)"
	@echo "  - Redis Commander: http://localhost:8082 (admin / admin)"

# Quick aliases
up: start ## Alias for start
down: stop ## Alias for stop
ps: status ## Alias for status
build: rebuild ## Alias for rebuild

# Docker commands with parameters
logs-rust: ## View Rust backend logs
	@make logs SERVICE=rust-backend

logs-socketio: ## View Socket.IO logs
	@make logs SERVICE=socketio-bridge

logs-frontend: ## View frontend logs
	@make logs SERVICE=frontend

logs-postgres: ## View PostgreSQL logs
	@make logs SERVICE=postgres

logs-redis: ## View Redis logs
	@make logs SERVICE=redis

shell-rust: ## Shell into Rust backend
	@make shell SERVICE=rust-backend

shell-postgres: ## Shell into PostgreSQL
	@make shell SERVICE=postgres

restart-rust: ## Restart Rust backend
	@docker-compose restart rust-backend
	@echo "$(GREEN)Rust backend restarted!$(NC)"

restart-socketio: ## Restart Socket.IO bridge
	@docker-compose restart socketio-bridge
	@echo "$(GREEN)Socket.IO bridge restarted!$(NC)"

